-- MySQL Script generated by MySQL Workbench
-- 08/14/15 14:38:18
-- Model: New Model    Version: 1.0
-- MySQL Workbench Forward Engineering

SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='ALLOW_INVALID_DATES';

-- -----------------------------------------------------
-- Schema qservMeta
-- -----------------------------------------------------

-- -----------------------------------------------------
-- Schema qservMeta
-- -----------------------------------------------------
CREATE SCHEMA IF NOT EXISTS `qservMeta` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci ;
USE `qservMeta` ;

-- -----------------------------------------------------
-- Table `QCzar`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `QCzar` (
  `czarId` INT NOT NULL AUTO_INCREMENT COMMENT 'Czar identifier',
  `czar` CHAR(63) NOT NULL COMMENT 'Czar unique name',
  `active` BIT NOT NULL COMMENT 'Set to 0 when czar disappears',
  PRIMARY KEY (`czarId`),
  UNIQUE INDEX `QCzar_czar_UNIQUE` (`czar` ASC))
ENGINE = InnoDB
COMMENT = 'Table for czars, definition of every czar ever existed.';


-- -----------------------------------------------------
-- Table `QInfo`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `QInfo` (
  `queryId` BIGINT NOT NULL AUTO_INCREMENT COMMENT 'Query identifier, unique number',
  `qType` ENUM('SYNC', 'ASYNC') NOT NULL COMMENT 'Query type, either SYNC or ASYNC.',
  `czarId` INT NOT NULL COMMENT 'ID of the \"responsible czar\" of this query',
  `user` CHAR(63) NOT NULL COMMENT 'Name (id) of the user submitting this query',
  `query` MEDIUMTEXT NOT NULL COMMENT 'Original query text as was submitted by client.',
  `qTemplate` MEDIUMTEXT NOT NULL COMMENT 'Query template, string used to build final per-chunk query.',
  `qMerge` MEDIUMTEXT NULL COMMENT 'Merge (or aggregate) query to be executed on results table, result of this query is stored in merge table. If NULL then it is equivalent to SELECT *.',
  `status` ENUM('EXECUTING', 'COMPLETED', 'FAILED', 'ABORTED') NOT NULL DEFAULT 'EXECUTING' COMMENT 'Status of query processing.',
  `submitted` TIMESTAMP NOT NULL DEFAULT  CURRENT_TIMESTAMP COMMENT 'Time when query was submitted (received from client)',
  `completed` TIMESTAMP NULL COMMENT 'Time when query processing is completed - either the results were collected into czar-side result table or failure is detected.',
  `returned` TIMESTAMP NULL COMMENT 'Time when result is sent back to user. NULL if not completed yet.',
  `messageTable` CHAR(63) NULL COMMENT 'Name of the message table for the ASYNC query',
  `resultLocation` TEXT NULL COMMENT 'Result destination - table name, file name, etc.',
  `resultQuery` MEDIUMTEXT NULL COMMENT 'Query to be used by mysqlproxy to get final results.',
  PRIMARY KEY (`queryId`),
  INDEX `QInfo_czarId_index` (`czarId` ASC),
  CONSTRAINT `QInfo_cid`
    FOREIGN KEY (`czarId`)
    REFERENCES `QCzar` (`czarId`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Table containing per-query information.';


-- -----------------------------------------------------
-- Table `QTable`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `QTable` (
  `queryId` BIGINT NOT NULL COMMENT 'Query identifier, foreign key into QueryInfo table',
  `dbName` CHAR(63) NOT NULL COMMENT 'Database name',
  `tblName` CHAR(63) NOT NULL COMMENT 'Table name',
  PRIMARY KEY (`queryId`, `dbName`, `tblName`),
  INDEX `QTable_TableNameIndex` (`dbName` ASC, `tblName` ASC),
  CONSTRAINT `QTable_qid`
    FOREIGN KEY (`queryId`)
    REFERENCES `QInfo` (`queryId`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Table containing table names used by query.';


-- -----------------------------------------------------
-- Table `QWorker`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `QWorker` (
  `queryId` BIGINT NOT NULL COMMENT 'Query ID',
  `chunk` INT NOT NULL COMMENT 'Chunk number',
  `wXrd` CHAR(63) NULL COMMENT 'Worker xrootd endpoint (host name/IP and port number)',
  `submitted` TIMESTAMP NULL DEFAULT NULL COMMENT 'Time when chunk query was submitted to worker',
  `completed` TIMESTAMP NULL DEFAULT NULL COMMENT 'Set to non-NULL when query result for this chunk is processed',
  PRIMARY KEY (`queryId`, `chunk`),
  CONSTRAINT `QWorker_qid`
    FOREIGN KEY (`queryId`)
    REFERENCES `QInfo` (`queryId`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
COMMENT = 'Mapping of queries to workers';

-- -----------------------------------------------------
-- Table `QStatsTmp`
-- MEMORY table - will be recreated(but empty) by mariadb every time server starts.
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `QStatsTmp` (
  `queryId` BIGINT NOT NULL COMMENT 'Query ID',
  `totalChunks` INT COMMENT 'Total number of chunks in the query',
  `completedChunks` INT COMMENT 'Number of completed chunks in the query',
  `queryBegin` TIMESTAMP DEFAULT 0 COMMENT 'When the query was started',
  `lastUpdate` TIMESTAMP DEFAULT 0 COMMENT 'Last time completedChunks was updated',
  PRIMARY KEY (`queryId`))
ENGINE = MEMORY
COMMENT = 'Table to track statistics of running queries.';

-- -----------------------------------------------------
-- View `ShowProcessList`
-- This shows abbreviated Qmeta info suitable for "SHOW PROCESSLIST"
-- -----------------------------------------------------
CREATE OR REPLACE
  SQL SECURITY INVOKER
  VIEW `ShowProcessList` AS
  SELECT DISTINCT
    `QInfo`.`queryId` `Id`,
    `QInfo`.`user` `User`,
    NULL `Host`,
    GROUP_CONCAT(DISTINCT `QTable`.`dbName`) `db`,
    `QInfo`.`qType` `Command`,
    NULL `Time`,
    `QInfo`.`status` `State`,
    `QInfo`.`query` `Info`,
    NULL `Progress`,
    `QInfo`.`submitted` `Submitted`,
    `QInfo`.`completed` `Completed`,
    `QInfo`.`returned` `Returned`,
    `QInfo`.`czarId` `CzarId`,
    REPLACE(`QInfo`.`resultLocation`, '#QID#',  `QInfo`.`queryId`) `ResultLocation`,
    `QStatsTmp`.`totalChunks` `TotalChunks`,
    `QStatsTmp`.`completedChunks` `CompletedChunks`,
    `QStatsTmp`.`lastUpdate` `LastUpdate`
  FROM `QInfo` LEFT OUTER JOIN `QTable` USING (`queryId`)
       LEFT OUTER JOIN `QStatsTmp` USING (`queryId`)
  GROUP BY `QInfo`.`queryId`;

-- -----------------------------------------------------
-- View `InfoSchemaProcessList`
-- This shows full Qmeta info suitable for "SELECT ... FROM INFORMATION_SCHEMA.PROCESSLIST"
-- -----------------------------------------------------
CREATE OR REPLACE
  SQL SECURITY INVOKER
  VIEW `InfoSchemaProcessList` AS
  SELECT DISTINCT
    `QInfo`.`queryId` `ID`,
    `QInfo`.`user` `USER`,
    NULL `HOST`,
    GROUP_CONCAT(DISTINCT `QTable`.`dbName`) `DB`,
    `QInfo`.`qType` `COMMAND`,
    NULL `TIME`,
    `QInfo`.`status` `STATE`,
    `QInfo`.`query` `INFO`,
    `QInfo`.`submitted` `SUBMITTED`,
    `QInfo`.`completed` `COMPLETED`,
    `QInfo`.`returned` `RETURNED`,
    `QInfo`.`czarId` `CZARID`,
    REPLACE(`QInfo`.`resultLocation`, '#QID#',  `QInfo`.`queryId`) `RESULTLOCATION`,
    NULLIF(COUNT(`QWorker`.`chunk`), 0) `NCHUNKS`,
    `QStatsTmp`.`totalChunks` `TotalChunks`,
    `QStatsTmp`.`completedChunks` `CompletedChunks`,
    `QStatsTmp`.`lastUpdate` `LastUpdate`
  FROM `QInfo` LEFT OUTER JOIN `QTable` USING (`queryId`)
        LEFT OUTER JOIN `QWorker` USING (`queryId`)
        LEFT OUTER JOIN `QStatsTmp` USING (`queryId`)
  GROUP BY `QInfo`.`queryId`;

-- -----------------------------------------------------
-- Table `QMetadata`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `QMetadata` (
  `metakey` CHAR(64) NOT NULL COMMENT 'Key string',
  `value` TEXT NULL COMMENT 'Key string',
  PRIMARY KEY (`metakey`))
ENGINE = InnoDB
COMMENT = 'Metadata about database as a whole, bunch of key-value pairs';

-- Update version on every schema change.
-- Version 0 corresponds to initial QMeta release and it had no
-- QMetadata table at all.
-- Version 1 introduced QMetadata table and altered schema for QInfo table
-- Version 2 added query progress data to ProcessList tables.
-- Version 3 added storing the result query in QMeta.
-- Version 4 migrated 4 TEXT columns `query`, `qTemplate`, `qMerge`
--   and `resultQuery` of QInfo to the MySQL type MEDIUMTEXT to allow larger
--   storage capacity.
INSERT INTO `QMetadata` (`metakey`, `value`) VALUES ('version', '4');

SET SQL_MODE=@OLD_SQL_MODE;
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;
